# План разработки проекта Speedcubing Competition Bot

## 1. Описание проекта

### 1.1. Суть проекта
Speedcubing Competition Bot - это телеграмм-бот для проведения онлайн-соревнований по спидкубингу (скоростной сборке кубика Рубика и других шарнирных головоломок). Бот предназначен для организации сходок спидкуберов и проведения небольших соревнований с автоматизированным подсчётом результатов согласно правилам WCA (World Cube Association).

### 1.2. Основные роли пользователей
- **Организаторы** - создают соревнования, загружают скрамблы (фото алгоритмов перемешивания), управляют соревнованиями
- **Участники** - регистрируются на соревнования, получают скрамблы, вводят результаты сборок

### 1.3. Ключевые функции
1. Создание и управление соревнованиями
2. Загрузка и распространение скрамблов в виде фотографий
3. Регистрация участников и сбор их результатов
4. Автоматический подсчёт среднего времени по правилам WCA для каждой дисциплины
5. Формирование таблиц лидеров по дисциплинам и общего зачёта
6. Система баллов для общего зачёта соревнований

---

## 2. Архитектура проекта

### 2.1. Структура папок

```
Speedcubing_competition_bot/
│
├── Documentation/                          # Документация проекта
│   ├── Project_description.md
│   ├── Development_plan.md
│   ├── List_of_WCA_disciplines.md
│   ├── Rules_for_calculating_competition_results.md
│   └── Competition_example.md
│
├── src/                                    # Основной код приложения
│   ├── __init__.py
│   │
│   ├── bot/                                # Логика телеграмм-бота
│   │   ├── __init__.py
│   │   ├── main.py                         # Точка входа бота
│   │   ├── handlers/                       # Обработчики команд и сообщений
│   │   │   ├── __init__.py
│   │   │   ├── start.py                    # /start, приветствие
│   │   │   ├── organizer_handlers.py       # Команды для организаторов
│   │   │   ├── participant_handlers.py     # Команды для участников
│   │   │   ├── competition_handlers.py     # Работа с соревнованиями
│   │   │   └── results_handlers.py         # Ввод и просмотр результатов
│   │   │
│   │   ├── keyboards/                      # Клавиатуры для бота
│   │   │   ├── __init__.py
│   │   │   ├── inline_keyboards.py         # Inline-клавиатуры
│   │   │   └── reply_keyboards.py          # Reply-клавиатуры
│   │   │
│   │   ├── states/                         # FSM состояния для диалогов
│   │   │   ├── __init__.py
│   │   │   ├── competition_states.py       # Состояния создания соревнований
│   │   │   ├── registration_states.py      # Состояния регистрации
│   │   │   └── result_submission_states.py # Состояния отправки результатов
│   │   │
│   │   └── utils/                          # Вспомогательные функции для бота
│   │       ├── __init__.py
│   │       ├── validators.py               # Валидация ввода данных
│   │       ├── formatters.py               # Форматирование сообщений
│   │       └── message_templates.py        # Шаблоны сообщений
│   │
│   ├── database/                           # Работа с базой данных
│   │   ├── __init__.py
│   │   ├── models.py                       # ORM модели SQLAlchemy
│   │   ├── database.py                     # Настройка подключения к БД
│   │   ├── crud/                           # CRUD операции
│   │   │   ├── __init__.py
│   │   │   ├── competition.py              # Операции с соревнованиями
│   │   │   ├── participant.py              # Операции с участниками
│   │   │   ├── discipline.py               # Операции с дисциплинами
│   │   │   ├── scramble.py                 # Операции со скрамблами
│   │   │   └── result.py                   # Операции с результатами
│   │   │
│   │   └── migrations/                     # Миграции базы данных (Alembic)
│   │       └── versions/
│   │
│   ├── services/                           # Бизнес-логика
│   │   ├── __init__.py
│   │   ├── competition_service.py          # Логика управления соревнованиями
│   │   ├── result_service.py               # Обработка результатов
│   │   ├── calculation_service.py          # Расчёт среднего времени
│   │   ├── leaderboard_service.py          # Формирование таблиц лидеров
│   │   ├── points_service.py               # Расчёт баллов для общего зачёта
│   │   └── discipline_service.py           # Работа с дисциплинами WCA
│   │
│   ├── storage/                            # Хранение файлов
│   │   ├── __init__.py
│   │   ├── file_manager.py                 # Управление файлами
│   │   └── scrambles/                      # Папка для хранения фото скрамблов
│   │
│   └── config/                             # Конфигурация
│       ├── __init__.py
│       ├── settings.py                     # Настройки приложения
│       └── disciplines_config.py           # Конфигурация дисциплин WCA
│
├── tests/                                  # Тесты
│   ├── __init__.py
│   ├── test_calculation_service.py         # Тесты расчёта среднего
│   ├── test_leaderboard_service.py         # Тесты таблиц лидеров
│   ├── test_points_service.py              # Тесты расчёта баллов
│   └── test_validators.py                  # Тесты валидации
│
├── .env.example                            # Пример файла с переменными окружения
├── .env                                    # Переменные окружения (не в git)
├── .gitignore                              # Игнорируемые файлы
├── requirements.txt                        # Зависимости проекта
├── alembic.ini                             # Конфигурация Alembic
└── README.md                               # Описание проекта
```

### 2.2. Обоснование архитектуры

**Разделение по слоям:**
- **bot/** - слой представления (взаимодействие с пользователем)
- **database/** - слой данных (работа с БД)
- **services/** - бизнес-логика (расчёты, обработка данных)
- **storage/** - файловое хранилище

Такая архитектура обеспечивает:
- Разделение ответственности (separation of concerns)
- Лёгкость тестирования
- Возможность замены компонентов (например, БД или файлового хранилища)
- Удобство поддержки и масштабирования

---

## 3. Технологический стек

### 3.1. Основные фреймворки и библиотеки

#### Для работы с Telegram API:
- **aiogram 3.x** - современный асинхронный фреймворк для создания телеграмм-ботов
  - Преимущества: асинхронность, встроенный FSM (Finite State Machine), удобная работа с клавиатурами
  - Альтернатива: python-telegram-bot

#### Для работы с базой данных:
- **SQLAlchemy 2.x** - ORM для работы с БД
- **asyncpg** - асинхронный драйвер для PostgreSQL
- **Alembic** - инструмент для миграций БД
- **PostgreSQL** - реляционная база данных

#### Для работы с конфигурацией:
- **python-dotenv** - загрузка переменных окружения из .env файла
- **pydantic** - валидация настроек и данных
- **pydantic-settings** - управление настройками приложения

#### Для работы с файлами:
- **aiofiles** - асинхронная работа с файлами
- **Pillow (PIL)** - обработка изображений (если потребуется)

#### Для тестирования:
- **pytest** - фреймворк для тестирования
- **pytest-asyncio** - поддержка асинхронных тестов
- **pytest-cov** - измерение покрытия кода тестами

#### Вспомогательные библиотеки:
- **loguru** - удобное логирование
- **redis** (опционально) - кэширование и хранение состояний FSM
- **APScheduler** (опционально) - планировщик задач (для напоминаний, автоматических действий)

### 3.2. Версия Python
- **Python 3.11+** - для использования современных возможностей языка

---

## 4. Архитектура базы данных

### 4.1. Основные таблицы

#### Таблица: **users**
Хранит информацию о всех пользователях бота
- `id` (PK) - уникальный ID
- `telegram_id` (UNIQUE) - ID пользователя в Telegram
- `username` - username в Telegram (может быть NULL)
- `first_name` - имя участника
- `last_name` - фамилия участника
- `role` - роль (participant, organizer, admin)
- `created_at` - дата регистрации
- `updated_at` - дата последнего обновления

#### Таблица: **competitions**
Хранит информацию о соревнованиях
- `id` (PK) - уникальный ID соревнования
- `name` - название соревнования (например, "Сходка 11.10.2025")
- `competition_code` - уникальный код соревнования для регистрации
- `organizer_id` (FK → users.id) - ID организатора
- `status` - статус (draft, active, completed, cancelled)
- `created_at` - дата создания
- `start_date` - дата начала (опционально)
- `end_date` - дата окончания (опционально)

#### Таблица: **disciplines**
Справочник дисциплин WCA
- `id` (PK) - уникальный ID дисциплины
- `name` - название дисциплины (например, "Кубик Рубика 3x3")
- `code` - короткий код (например, "3x3", "2x2", "3x3_OH")
- `attempts_count` - количество попыток (3 или 5)
- `average_calculation_type` - тип расчёта среднего (mean_of_3, ao5, best_of_3)
  - `mean_of_3` - среднее арифметическое 3 попыток (6x6, 7x7)
  - `ao5` - average of 5 (убирается лучшая и худшая, среднее из 3)
  - `best_of_3` - лучшая из 3 попыток (блайнды, мультиблайнд)
- `dnf_threshold` - количество DNF для автоматического DNF среднего
- `max_time_minutes` - максимальное допустимое время (10 минут)

**Примечание:** Таблица disciplines должна быть заполнена заранее на основе файла `List_of_WCA_disciplines.md`. Всего 16 дисциплин.

#### Таблица: **competition_disciplines**
Связь многие-ко-многим между соревнованиями и дисциплинами
- `id` (PK)
- `competition_id` (FK → competitions.id)
- `discipline_id` (FK → disciplines.id)
- `is_active` - активна ли дисциплина в соревновании

**Уникальное ограничение:** (competition_id, discipline_id)

#### Таблица: **scrambles**
Хранит скрамблы (фотографии) для каждой дисциплины в соревновании
- `id` (PK)
- `competition_id` (FK → competitions.id)
- `discipline_id` (FK → disciplines.id)
- `attempt_number` - номер попытки (1, 2, 3, 4, 5)
- `file_id` - file_id фотографии в Telegram (для быстрой отправки)
- `file_path` - путь к сохранённому файлу на сервере
- `uploaded_at` - дата загрузки

**Уникальное ограничение:** (competition_id, discipline_id, attempt_number)

#### Таблица: **participants**
Участники конкретных соревнований
- `id` (PK)
- `competition_id` (FK → competitions.id)
- `user_id` (FK → users.id)
- `registration_date` - дата регистрации на соревнование

**Уникальное ограничение:** (competition_id, user_id)

#### Таблица: **results**
Результаты участников по дисциплинам
- `id` (PK)
- `participant_id` (FK → participants.id)
- `discipline_id` (FK → disciplines.id)
- `attempt_1_time` - время первой попытки (в миллисекундах или NULL для DNF)
- `attempt_1_dnf` - флаг DNF для первой попытки
- `attempt_2_time` - время второй попытки
- `attempt_2_dnf` - флаг DNF для второй попытки
- `attempt_3_time` - время третьей попытки
- `attempt_3_dnf` - флаг DNF для третьей попытки
- `attempt_4_time` - время четвёртой попытки (NULL для дисциплин с 3 попытками)
- `attempt_4_dnf` - флаг DNF для четвёртой попытки
- `attempt_5_time` - время пятой попытки (NULL для дисциплин с 3 попытками)
- `attempt_5_dnf` - флаг DNF для пятой попытки
- `average_time` - среднее время (рассчитывается автоматически)
- `average_dnf` - флаг DNF для среднего
- `best_time` - лучшее время (для разрешения одинаковых средних)
- `submitted_at` - дата/время отправки результатов
- `updated_at` - дата последнего обновления

**Уникальное ограничение:** (participant_id, discipline_id)

**Примечание:** Время хранится в миллисекундах (INTEGER) для точности и удобства сравнения. При отображении конвертируется в формат MM.SS.MS.

#### Таблица: **leaderboards**
Таблица лидеров по дисциплинам (денормализация для быстрого доступа)
- `id` (PK)
- `competition_id` (FK → competitions.id)
- `discipline_id` (FK → disciplines.id)
- `user_id` (FK → users.id)
- `position` - место в таблице
- `average_time` - среднее время
- `average_dnf` - флаг DNF
- `best_time` - лучшее время
- `points` - баллы за эту дисциплину в общий зачёт
- `calculated_at` - дата расчёта

**Уникальное ограничение:** (competition_id, discipline_id, user_id)

#### Таблица: **overall_leaderboard**
Общая таблица лидеров соревнований
- `id` (PK)
- `competition_id` (FK → competitions.id)
- `user_id` (FK → users.id)
- `total_points` - общая сумма баллов
- `disciplines_participated` - количество дисциплин, в которых участвовал
- `position` - итоговое место
- `calculated_at` - дата расчёта

**Уникальное ограничение:** (competition_id, user_id)

### 4.2. Индексы

Для оптимизации запросов необходимо создать индексы на:
- `users.telegram_id`
- `competitions.competition_code`
- `scrambles(competition_id, discipline_id)`
- `participants(competition_id, user_id)`
- `results(participant_id, discipline_id)`
- `leaderboards(competition_id, discipline_id)`
- `overall_leaderboard(competition_id)`

---

## 5. Пошаговый план разработки

### Этап 1: Подготовка инфраструктуры (1-2 дня)

#### 1.1. Настройка проекта
- Создать структуру папок согласно разделу 2.1
- Инициализировать Git репозиторий
- Создать виртуальное окружение Python
- Создать файл requirements.txt с необходимыми зависимостями
- Создать .env.example и .gitignore

#### 1.2. Настройка базы данных
- Установить и настроить PostgreSQL (или SQLite для начала)
- Настроить SQLAlchemy подключение в `src/database/database.py`
- Инициализировать Alembic для миграций

#### 1.3. Базовая настройка бота
- Создать бота через @BotFather в Telegram
- Получить токен бота
- Создать файл конфигурации `src/config/settings.py` с использованием pydantic-settings
- Создать базовую точку входа в `src/bot/main.py`

### Этап 2: Разработка моделей данных (2-3 дня)

#### 2.1. Создание ORM моделей
- Создать все модели в `src/database/models.py` согласно разделу 4.1:
  - User
  - Competition
  - Discipline
  - CompetitionDiscipline
  - Scramble
  - Participant
  - Result
  - Leaderboard
  - OverallLeaderboard
- Настроить связи между моделями (relationships)

#### 2.2. Создание первой миграции
- Сгенерировать миграцию с помощью Alembic
- Применить миграцию к БД
- Проверить создание всех таблиц

#### 2.3. Наполнение справочника дисциплин
- Создать скрипт или миграцию для заполнения таблицы disciplines
- Заполнить таблицу на основе файла `Documentation/List_of_WCA_disciplines.md`
- Указать для каждой дисциплины:
  - Название
  - Код
  - Количество попыток (3 или 5)
  - Тип расчёта среднего
  - Порог DNF

#### 2.4. Создание CRUD операций
- Реализовать базовые CRUD операции в папке `src/database/crud/`:
  - `competition.py` - создание, получение, обновление соревнований
  - `participant.py` - регистрация участников
  - `discipline.py` - получение дисциплин
  - `scramble.py` - сохранение и получение скрамблов
  - `result.py` - сохранение и получение результатов

### Этап 3: Конфигурация дисциплин WCA (1 день)

#### 3.1. Создание конфигурационного файла
- Создать `src/config/disciplines_config.py`
- Описать конфигурацию каждой дисциплины:
  - Правила расчёта среднего
  - Количество попыток
  - Особые правила (например, для мультиблайнда)

**Важно:** Обратиться к файлу `Documentation/List_of_WCA_disciplines.md` для точного определения правил каждой дисциплины.

### Этап 4: Сервисный слой - расчёты и логика (3-4 дня)

#### 4.1. Сервис расчёта среднего времени
Создать `src/services/calculation_service.py` с функциями:
- `calculate_average_ao5(attempts)` - для дисциплин с 5 попытками
  - Убрать лучшую и худшую попытку
  - Рассчитать среднее из 3 оставшихся
  - Вернуть DNF если 2+ попыток с DNF
- `calculate_average_mean_of_3(attempts)` - для 6x6, 7x7
  - Среднее арифметическое из 3 попыток
  - Вернуть DNF если хотя бы 1 попытка DNF
- `calculate_best_of_3(attempts)` - для блайндов
  - Вернуть лучшую из 3 попыток
  - Вернуть DNF только если все попытки DNF
- `get_best_time(attempts)` - для определения лучшей попытки

**Важно:** Обратиться к файлу `Documentation/List_of_WCA_disciplines.md` раздел "Правила подсчёта среднего времени".

#### 4.2. Сервис обработки результатов
Создать `src/services/result_service.py` с функциями:
- `save_result(participant_id, discipline_id, attempts)` - сохранение результата
  - Валидация попыток
  - Автоматический расчёт среднего и лучшей попытки
  - Сохранение в БД
- `update_result(result_id, attempts)` - обновление результата
- `get_participant_results(participant_id, competition_id)` - получение всех результатов участника

#### 4.3. Сервис формирования таблицы лидеров
Создать `src/services/leaderboard_service.py` с функциями:
- `calculate_discipline_leaderboard(competition_id, discipline_id)` - таблица лидеров по дисциплине
  - Получить все результаты участников
  - Отсортировать по среднему времени (DNF в конец)
  - При одинаковом среднем - сортировать по лучшей попытке
  - Присвоить места
  - Сохранить в таблицу leaderboards
- `get_discipline_leaderboard(competition_id, discipline_id)` - получение таблицы
- `format_leaderboard_message(leaderboard_data)` - форматирование для отправки в Telegram

**Важно:** Обратиться к файлу `Documentation/Rules_for_calculating_competition_results.md` раздел "Правила формирования таблицы лидеров по конкретной дисциплины".

#### 4.4. Сервис расчёта баллов и общего зачёта
Создать `src/services/points_service.py` с функциями:
- `calculate_points_for_discipline(position, total_participants, participants_with_dnf)` - расчёт баллов
  - Формула: X = Y - N + 1
  - где Y = total_participants - participants_with_dnf
  - N = position
  - Для DNF возвращать 0
- `calculate_overall_leaderboard(competition_id)` - общая таблица лидеров
  - Для каждого участника рассчитать баллы по всем дисциплинам
  - Суммировать баллы
  - Отсортировать по убыванию суммы баллов
  - Присвоить итоговые места
  - Сохранить в overall_leaderboard
- `get_overall_leaderboard(competition_id)` - получение общей таблицы

**Важно:** Обратиться к файлу `Documentation/Rules_for_calculating_competition_results.md` раздел "Общая таблица лидеров".

#### 4.5. Сервис работы с соревнованиями
Создать `src/services/competition_service.py` с функциями:
- `create_competition(name, organizer_id, disciplines)` - создание соревнования
  - Генерация уникального кода соревнования
  - Создание записи в БД
  - Связывание с выбранными дисциплинами
- `add_disciplines_to_competition(competition_id, discipline_ids)` - добавление дисциплин
- `get_competition_info(competition_id)` - получение информации
- `get_competition_by_code(code)` - поиск по коду
- `complete_competition(competition_id)` - завершение соревнования

### Этап 5: Валидация и утилиты (1-2 дня)

#### 5.1. Валидаторы
Создать `src/bot/utils/validators.py` с функциями:
- `validate_time_format(time_string)` - проверка формата времени
  - Формат: X.Y.Z или DNF
  - X - минуты (0-10)
  - Y - секунды (0-59)
  - Z - миллисекунды (0-99)
  - Если X > 10, автоматически DNF
  - Вернуть время в миллисекундах или None для DNF
- `validate_attempts_count(attempts, required_count)` - проверка количества попыток
- `parse_time_input(text)` - парсинг введённых времён

**Важно:** Обратиться к файлу `Documentation/Project_description.md` пункт 5 про формат времени.

#### 5.2. Форматирование
Создать `src/bot/utils/formatters.py` с функциями:
- `format_time(milliseconds)` - конвертация миллисекунд в MM.SS.MS или DNF
- `format_participant_name(first_name, last_name)` - форматирование имени
- `format_discipline_name(discipline)` - форматирование названия дисциплины

#### 5.3. Шаблоны сообщений
Создать `src/bot/utils/message_templates.py` с шаблонами:
- Приветственное сообщение
- Сообщение о создании соревнования
- Сообщение для ввода результатов (с автозаполнением)
- Сообщения об ошибках
- Форматы таблиц лидеров

### Этап 6: Обработчики команд бота (4-5 дней)

#### 6.1. Базовые команды
Создать `src/bot/handlers/start.py`:
- `/start` - приветствие и главное меню
- `/help` - справка по командам
- Выбор роли (организатор/участник) при первом запуске
- Сохранение пользователя в БД

#### 6.2. Команды для организаторов
Создать `src/bot/handlers/organizer_handlers.py`:

**Создание соревнования:**
- `/create_competition` - начать создание соревнования
- FSM: запросить название соревнования
- FSM: показать список дисциплин WCA, разрешить выбрать несколько
- FSM: для каждой выбранной дисциплины запросить скрамблы (фотографии)
  - Проверить, что количество фото соответствует количеству попыток
  - Сохранить file_id и скачать файлы
- Создать соревнование в БД
- Вернуть код соревнования организатору

**Управление соревнованием:**
- `/my_competitions` - список соревнований организатора
- `/competition_info <code>` - информация о соревновании
- `/add_disciplines <code>` - добавить дисциплины к существующему соревнованию
- `/complete_competition <code>` - завершить соревнование

**Просмотр результатов:**
- `/view_results <code>` - просмотр всех результатов
- `/discipline_leaderboard <code> <discipline>` - таблица лидеров по дисциплине
- `/overall_leaderboard <code>` - общая таблица лидеров

**Важно:** См. `Documentation/Competition_example.md` раздел "Подготовка".

#### 6.3. Команды для участников
Создать `src/bot/handlers/participant_handlers.py`:

**Регистрация на соревнование:**
- `/register <code>` - регистрация на соревнование
- FSM: запросить имя участника
- FSM: запросить фамилию участника
- Сохранить участника в БД

**Получение скрамблов:**
- `/get_scrambles <code> <discipline>` - получить скрамблы по дисциплине
- Показать список дисциплин для выбора
- Отправить фотографии скрамблов участнику

**Важно:** См. `Documentation/Project_description.md` пункт 3.

#### 6.4. Ввод результатов
Создать `src/bot/handlers/results_handlers.py`:

**Отправка результатов:**
- `/submit_results <code> <discipline>` - начать ввод результатов
- Показать список дисциплин для выбора
- FSM: отправить шаблон сообщения с полями для ввода:
  ```
  Дисциплина: Кубик Рубика 3x3
  Сборка 1: 
  Сборка 2: 
  Сборка 3: 
  Сборка 4: 
  Сборка 5: 
  ```
- FSM: получить заполненное сообщение
- Распарсить времена
- Валидировать формат каждого времени
- Если формат неверный - вывести ошибку и попросить повторить
- Сохранить результаты через result_service
- Автоматически рассчитать среднее
- Отправить подтверждение с рассчитанным средним

**Просмотр своих результатов:**
- `/my_results <code>` - просмотр своих результатов в соревновании
- `/my_position <code> <discipline>` - моё место по дисциплине

**Важно:** См. `Documentation/Competition_example.md` раздел "Ход соревнований" и `Documentation/Project_description.md` пункты 4-5.

#### 6.5. Просмотр таблиц лидеров
Создать обработчики для:
- `/leaderboard <code> <discipline>` - таблица по дисциплине (доступна всем)
- `/overall <code>` - общая таблица (доступна всем)

**Важно:** См. `Documentation/Competition_example.md` раздел "Подсчёт результатов".

#### 6.6. FSM состояния
Создать файлы состояний:
- `src/bot/states/competition_states.py` - состояния создания соревнования
  - EnterCompetitionName
  - SelectDisciplines
  - UploadScrambles (для каждой дисциплины)
- `src/bot/states/registration_states.py` - состояния регистрации
  - EnterFirstName
  - EnterLastName
- `src/bot/states/result_submission_states.py` - состояния ввода результатов
  - SelectDiscipline
  - EnterResults

#### 6.7. Клавиатуры
Создать `src/bot/keyboards/inline_keyboards.py`:
- Клавиатура выбора роли (организатор/участник)
- Клавиатура списка дисциплин (для выбора нескольких)
- Клавиатура выбора дисциплины (для получения скрамблов/ввода результатов)
- Клавиатура подтверждения действий

Создать `src/bot/keyboards/reply_keyboards.py` (если нужно):
- Главное меню
- Меню организатора
- Меню участника

### Этап 7: Хранение файлов (1 день)

#### 7.1. Файловый менеджер
Создать `src/storage/file_manager.py`:
- `save_scramble_photo(photo, competition_id, discipline_id, attempt_number)` - сохранение фото
  - Создать структуру папок: `scrambles/competition_{id}/discipline_{id}/`
  - Сохранить файл с именем `attempt_{n}.jpg`
  - Вернуть путь к файлу
- `get_scramble_photo_path(competition_id, discipline_id, attempt_number)` - получение пути
- `delete_competition_scrambles(competition_id)` - удаление скрамблов соревнования

### Этап 8: Тестирование (2-3 дня)

#### 8.1. Юнит-тесты
Создать тесты в папке `tests/`:
- `test_calculation_service.py` - тесты расчёта среднего
  - Проверить расчёт ao5 с различными комбинациями
  - Проверить обработку DNF
  - Проверить mean_of_3
  - Проверить best_of_3
- `test_leaderboard_service.py` - тесты таблиц лидеров
  - Проверить сортировку по среднему
  - Проверить обработку одинаковых средних (сортировка по лучшей попытке)
  - Проверить обработку DNF
- `test_points_service.py` - тесты расчёта баллов
  - Проверить формулу расчёта баллов
  - Проверить обработку DNF (0 баллов)
  - Проверить общий зачёт
- `test_validators.py` - тесты валидации
  - Проверить различные форматы времени
  - Проверить обработку некорректного ввода
  - Проверить автоматический DNF при X > 10

**Важно:** Использовать примеры из `Documentation/Competition_example.md` для создания тестовых данных.

#### 8.2. Интеграционные тесты
- Тестирование создания соревнования end-to-end
- Тестирование регистрации участника и ввода результатов
- Тестирование формирования таблиц лидеров

#### 8.3. Ручное тестирование
- Создать тестовое соревнование в боте
- Пройти полный цикл: создание → регистрация → ввод результатов → таблицы лидеров
- Проверить обработку ошибок ввода
- Проверить корректность расчётов

### Этап 9: Логирование и обработка ошибок (1 день)

#### 9.1. Настройка логирования
- Настроить loguru в `src/bot/main.py`
- Логировать все важные действия:
  - Создание соревнований
  - Регистрация участников
  - Ввод результатов
  - Расчёты
  - Ошибки

#### 9.2. Обработка ошибок
- Обработчик глобальных ошибок в боте
- Уведомление организаторов при критических ошибках
- Понятные сообщения об ошибках для пользователей

### Этап 10: Документация и деплой (1-2 дня)

#### 10.1. Документация
- Обновить README.md:
  - Описание проекта
  - Инструкция по установке
  - Инструкция по настройке
  - Инструкция по запуску
  - Список команд бота
- Создать INSTALL.md с подробной инструкцией установки
- Создать USER_GUIDE.md с руководством пользователя

#### 10.2. Подготовка к деплою
- Создать Dockerfile (опционально)
- Создать docker-compose.yml (опционально)
- Настроить systemd service для автозапуска (для Linux сервера)
- Создать скрипты для резервного копирования БД

#### 10.3. Деплой
- Выбрать хостинг (VPS, облако и т.д.)
- Развернуть PostgreSQL
- Развернуть бота
- Настроить автоматический запуск
- Настроить резервное копирование

### Этап 11: Оптимизация и улучшения (опционально)

#### 11.1. Производительность
- Добавить кэширование часто запрашиваемых данных (Redis)
- Оптимизировать запросы к БД (добавить индексы, использовать eager loading)
- Асинхронная обработка загрузки файлов

#### 11.2. Дополнительные функции
- Уведомления участникам о начале соревнований
- Напоминания о необходимости ввести результаты
- Экспорт таблиц лидеров в PDF/Excel
- Статистика по соревнованиям
- Графики и визуализация результатов
- Возможность редактирования результатов
- История соревнований участника
- Рейтинг участников по всем соревнованиям

#### 11.3. Административные функции
- Панель администратора
- Модерация соревнований
- Блокировка пользователей
- Статистика использования бота

---

## 6. Важные технические детали

### 6.1. Формат хранения времени
- **В базе данных:** хранить время в миллисекундах (INTEGER)
- **При вводе:** формат X.Y.Z (минуты.секунды.миллисекунды)
- **При отображении:** конвертировать обратно в читаемый формат
- **Преимущества:** точность, простота сравнения, отсутствие проблем с плавающей точкой

Пример:
- Ввод: `1.23.45` (1 минута 23.45 секунды)
- Хранение: `83450` миллисекунд
- Отображение: `1:23.45`

### 6.2. Обработка DNF
- DNF хранится как NULL в поле времени + флаг `_dnf = True`
- При расчётах DNF всегда считается худшим результатом
- Если DNF встречается в нужном количестве попыток (зависит от дисциплины), среднее = DNF

### 6.3. Генерация кода соревнования
- Использовать уникальный код (например, UUID или короткий хеш)
- Проверять уникальность перед сохранением
- Делать код коротким и удобным для ввода (например, 6-8 символов)

### 6.4. Состояния FSM
- Использовать FSM (Finite State Machine) для многошаговых диалогов
- Хранить состояния в Redis (производительность) или в памяти (простота)
- Обязательно обрабатывать отмену операции на любом шаге

### 6.5. Безопасность
- Валидировать все вводимые данные
- Ограничить размер загружаемых файлов
- Защита от SQL-инъекций (ORM это делает автоматически)
- Ограничение частоты запросов (rate limiting)
- Права доступа: только организатор может управлять своими соревнованиями

### 6.6. Масштабируемость
- Использовать асинхронность (aiogram + asyncpg)
- Индексы в БД для быстрого поиска
- Кэширование для часто запрашиваемых данных
- Пагинация для длинных списков

---

## 7. Справочная информация для программистов

### 7.1. Ключевые файлы документации
При реализации необходимо постоянно обращаться к следующим файлам:

1. **`Documentation/Project_description.md`** - основное описание функционала
2. **`Documentation/List_of_WCA_disciplines.md`** - список дисциплин и правила расчёта среднего
3. **`Documentation/Rules_for_calculating_competition_results.md`** - правила формирования таблиц лидеров и расчёта баллов
4. **`Documentation/Competition_example.md`** - практический пример проведения соревнований

### 7.2. Критические моменты реализации

#### Расчёт среднего времени (очень важно!)
- **Дисциплины с 5 попытками** (2x2, 3x3, 4x4, 5x5, 3x3 OH, мегаминкс, пирамидка, скваер, скьюб, клок):
  - Убрать лучшую и худшую
  - Среднее из 3 оставшихся
  - Если 2+ DNF → среднее = DNF
  
- **Дисциплины с 3 попытками (6x6, 7x7)**:
  - Среднее арифметическое всех 3
  - Если хотя бы 1 DNF → среднее = DNF
  
- **Блайнды (3x3, 4x4, 5x5) и мультиблайнд**:
  - Лучшая из попыток
  - Только если все DNF → среднее = DNF

#### Формирование таблицы лидеров по дисциплине
1. Сортировка по среднему времени (меньше = лучше)
2. DNF всегда в конце
3. При одинаковом среднем → сравнивать лучшую попытку
4. Присвоить места (1, 2, 3, ...)

#### Расчёт баллов для общего зачёта
Формула: **X = Y - N + 1**
- X - баллы участника за дисциплину
- Y - количество участников БЕЗ DNF в среднем
- N - место участника в таблице лидеров
- Если среднее = DNF → 0 баллов

Пример: 15 участников, 2 с DNF
- 1 место: 13 - 1 + 1 = 13 баллов
- 2 место: 13 - 2 + 1 = 12 баллов
- DNF: 0 баллов

#### Формат ввода времени
- Формат: `X.Y.Z` или `DNF`
- X - минуты (0-10), если X > 10 → автоматически DNF
- Y - секунды (0-59)
- Z - миллисекунды (0-99), округление до сотых
- Примеры валидного ввода: `0.12.34`, `1.05.99`, `DNF`, `0.59.99`
- Примеры невалидного ввода: `12.34`, `1:23.45`, `abc`

---

## 8. Потенциальные проблемы и решения

### 8.1. Проблема: Большое количество участников в одном соревновании
**Решение:** 
- Пагинация при отображении таблиц лидеров
- Кэширование рассчитанных таблиц
- Асинхронная обработка результатов

### 8.2. Проблема: Одновременная отправка результатов несколькими участниками
**Решение:**
- Использование транзакций БД
- Блокировки на уровне БД (SELECT FOR UPDATE)
- Очередь задач для пересчёта таблиц лидеров

### 8.3. Проблема: Хранение большого количества фотографий
**Решение:**
- Использовать file_id Telegram для повторной отправки (не скачивать каждый раз)
- Опционально: хранить в облаке (S3, Cloudinary)
- Сжатие изображений при сохранении
- Удаление скрамблов старых соревнований

### 8.4. Проблема: Неправильный ввод результатов участниками
**Решение:**
- Строгая валидация на каждом шаге
- Понятные сообщения об ошибках с примерами
- Возможность отменить и повторить ввод
- Возможность редактирования результатов (для организатора)

### 8.5. Проблема: Разные часовые пояса участников
**Решение:**
- Хранить все даты/времена в UTC
- Опционально: позволить участникам указать свой часовой пояс
- Отображать время с учётом часового пояса пользователя

---

## 9. Метрики успеха проекта

### 9.1. Функциональные метрики
- ✅ Все 16 дисциплин WCA поддерживаются
- ✅ Расчёт среднего работает корректно для каждой дисциплины
- ✅ Таблицы лидеров формируются правильно
- ✅ Система баллов работает согласно правилам WCA
- ✅ Валидация ввода времени работает безошибочно

### 9.2. Технические метрики
- ✅ Время отклика бота < 1 секунды для простых команд
- ✅ Поддержка минимум 100 одновременных пользователей
- ✅ Покрытие кода тестами > 70%
- ✅ Отсутствие критических ошибок в продакшене
- ✅ Доступность бота > 99%

### 9.3. Пользовательские метрики
- ✅ Интуитивно понятный интерфейс
- ✅ Все ошибки ввода понятно объясняются
- ✅ Организатор может создать соревнование за < 5 минут
- ✅ Участник может ввести результаты за < 2 минуты

---

## 10. Roadmap дальнейшего развития

### Фаза 1 (MVP - Minimum Viable Product)
- ✅ Базовый функционал создания соревнований
- ✅ Регистрация участников
- ✅ Ввод результатов
- ✅ Таблицы лидеров
- ✅ Общий зачёт

### Фаза 2 (Улучшения UX)
- 🔄 Редактирование результатов
- 🔄 Уведомления участникам
- 🔄 Экспорт таблиц в PDF/Excel
- 🔄 Графики и статистика

### Фаза 3 (Расширенный функционал)
- 📋 История всех соревнований участника
- 📋 Общий рейтинг участников
- 📋 Достижения и значки
- 📋 Веб-интерфейс для просмотра результатов

### Фаза 4 (Интеграции)
- 📋 Интеграция с официальными соревнованиями WCA
- 📋 API для сторонних приложений
- 📋 Мобильное приложение

---

## Заключение

Данный план разработки представляет собой полное руководство для создания телеграмм-бота Speedcubing Competition Bot. План детально описывает архитектуру, технологический стек, структуру базы данных и пошаговый процесс разработки.

**Ключевые принципы разработки:**
1. Строгое следование правилам WCA (согласно документации)
2. Модульная архитектура для лёгкой поддержки
3. Надёжная валидация всех вводимых данных
4. Автоматизация расчётов и формирования таблиц
5. Удобный пользовательский интерфейс

**Обязательно обращаться к файлам:**
- `Documentation/Project_description.md` - для понимания основного функционала
- `Documentation/List_of_WCA_disciplines.md` - для реализации расчёта среднего
- `Documentation/Rules_for_calculating_competition_results.md` - для таблиц лидеров и баллов
- `Documentation/Competition_example.md` - для понимания практического использования

**Расчётное время разработки:** 3-4 недели для опытного Python разработчика при работе full-time.

**Следующий шаг:** Начать с Этапа 1 - подготовка инфраструктуры и настройка окружения разработки.

